---
layout: post
tags: langdev coding
---

(Wait, that song was by Van Halen??)

I've just finished implementing and testing a bunch of keywords for Toy, and I found the hardest part so far is managing the JUMP opcodes. In this article, I'm going to vent a bit, and layout what's happening internally. This will be super casual and technical, but at least I'm writing an article this week.

<!--more-->

[![toy asm](/assets/toy_asm.png)](https://github.com/Ratstail91/Toy)
<center><em>Oh look, a pretty picture!</em></center>

<br>

Side Note: It took well over an hour to decompile the generated bytecode into that assembly display - I had to do it twice while debugging, so I've decided my next task will be to build a disassembler.

A few years ago, I planned out each keyword I wanted for Toy, using the logical layout for each, with the intent to reduce them to as few opcodes as I could get away with. I ended up with a few decent one-byte opcodes that were essentially self-contained, although some keywords resulted in multiple opcodes.

Side Note: I should explain how my opcodes work: The bytecode needs to be aligned in memory to the nearest 4 bytes (called a "word"), otherwise pointers, etc. misbehave. I took advantage of this to add extra "settings" to the opcodes in addition to their "parameters".

The first byte of a word is the opcode. The second, third and fourth are set to zero by default. Instead of wasting this space, I stored extra metadata, dubbed "settings", in these bytes. Exactly what each setting does varies according to the opcode. The "parameters" are stored in 4-byte words directly following this, and the whole thing makes up an "instruction".

## Jump

one specific opcode was `TOY_OPCODE_JUMP` (called JUMP here for brevity), which had two settings: "jump type" and "jump condition". It also took one parameter, which is interpreted based on the settings. So, in total, the whole instruction for JUMP consists of 8 bytes.

The "jump type" setting tells how the parameter is processed: `TOY_OP_PARAM_JUMP_ABSOLUTE` means "the parameter is an offset from the beginning of the code", while `TOY_OP_PARAM_JUMP_RELATIVE` means "the parameter is an offset from the current position, after this instruction has been read".

So, for `JUMP_ABSOLUTE`, if the parameter is 60, the program counter will be moved to that instruction, and for `JUMP_RELATIVE`, the 60 will be *added* to the program counter. The latter setting also supports negative values, which is useful for writing loops.

The second setting, "jump condition", tells if the jump instruction should be preformed or not - the options are `TOY_OP_PARAM_JUMP_ALWAYS`, `TOY_OP_PARAM_JUMP_IF_TRUE` and `TOY_OP_PARAM_JUMP_IF_FALSE`. The first means the jump will always happen. The second and third will pop the top value from the program stack, evaluate its truthiness, and will jump only if its true or false, respectfully. This is how the `if` statements are implemented - with interleaved instances of the JUMP instruction.

Here's my (slightly cleaned up) notes for the if-then-else statements:

```txt
if-then:
	cond-branch
	if false jump end
	{
		then-branch
	}
	end:

if-then-else:
	cond-branch
	if false jump else
	{
		then-branch
	}
	jump end
	else:
	{
		else-branch
	}
	end:
```

I might come back later and add in the disassembler output, but I'll be buggered if I'm doing it now.

## Escape

The above layout was just fine for simple jumps, but when you factor in the existence of scoped variables, all of a sudden you'll corrupt the program's logic unless you also pop the correct number of scopes.

```toy
while (true) {
	{
		{
			break;
			continue;
		}
	}
}
```

For the `break` and `continue` keywords, I created a new opcode, `TOY_OPCODE_ESCAPE` (or just ESCAPE). This 

## Functions??

...

"GOTO considered harmful" indeed.

